'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function compile(_ref) {
    var vShader = _ref.vShader,
        fShader = _ref.fShader,
        gl = _ref.gl,
        options = _ref.options;


    var textureCount = 0;

    function createShaderProgram(vShaderSource, fShaderSource, gl) {

        function loadShader(gl, type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                throw 'An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader);
            }
            return shader;
        }

        var fShader = loadShader(gl, gl.FRAGMENT_SHADER, fShaderSource);
        var vShader = loadShader(gl, gl.VERTEX_SHADER, vShaderSource);

        var program = gl.createProgram();
        gl.attachShader(program, vShader);
        gl.attachShader(program, fShader);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw 'Unable to initialize the shader program: ' + gl.getProgramInfoLog(program);
        }

        var uniforms = [];
        var attributes = [];

        var attributeCount = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);

        for (var i = 0; i < attributeCount; i++) {
            var attribute = gl.getActiveAttrib(program, i);
            attributes.push(attribute);
        }
        var uniformCount = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
        for (var _i = 0; _i < uniformCount; _i++) {
            var uniform = gl.getActiveUniform(program, _i);
            uniforms.push(uniform);
        }

        return {
            program: program,
            uniforms: uniforms, attributes: attributes
        };
    }

    function getType(value, gl) {
        var types = ['FLOAT', 'FLOAT_VEC2', 'FLOAT_VEC3', 'FLOAT_VEC4', 'FLOAT_MAT2', 'FLOAT_MAT3', 'FLOAT_MAT4', 'INT', 'INT_VEC2', 'INT_VEC3', 'INT_VEC4', 'BOOL', 'BOOL_VEC2', 'BOOL_VEC3', 'BOOL_VEC4', 'SAMPLER_2D', 'SAMPLER_CUBE'];

        for (var i = 0; i < types.length; i++) {
            if (gl[types[i]] === value) {
                return types[i];
            }
        }

        throw 'get type failed ' + value;
    }

    function attributeManager(attribute, program, gl) {
        var manager = {};
        var type = getType(attribute.type, gl);
        var position = gl.getAttribLocation(program, attribute.name);

        var baseType = type.split('_')[0];
        var vecType = type.split('_').length > 1 ? type.split('_')[1] : 'VEC1';
        var vecSize = Number(vecType[3]);

        var arrayTypeMap = {
            'FLOAT': Float32Array,
            'INT': Int16Array,
            'BOOL': Uint8Array
        };
        var ArrayType = arrayTypeMap[baseType];

        manager.fill = function (buffer) {
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(position, vecSize, gl[baseType], false, 0, 0);
            gl.enableVertexAttribArray(position);
        };

        manager.createBuffer = function (value) {
            var buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new ArrayType(value), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            return buffer;
        };

        return _extends({
            type: type }, manager);
    }

    function uniformManager(uniform, program, gl) {
        var manager = {};
        var type = getType(uniform.type, gl);
        var position = gl.getUniformLocation(program, uniform.name);

        var baseType = type.split('_')[0];
        var vecType = type.split('_').length > 1 ? type.split('_')[1] : 'VEC1';
        var baseVecType = vecType.substr(0, 3);
        var vecSize = Number(vecType[3]);

        var arrayTypeMap = {
            'FLOAT': Float32Array,
            'INT': Int32Array,
            'BOOL': Uint8Array
        };
        var ArrayType = arrayTypeMap[baseType];

        var uniformMethodName = void 0;
        switch (baseVecType) {
            case 'VEC':
                uniformMethodName = ['uniform', vecSize, baseType === 'FLOAT' ? 'f' : 'i', 'v'].join('');
                manager.fill = function (data) {
                    gl[uniformMethodName](position, new ArrayType(data));
                };
                break;
            case 'MAT':
                uniformMethodName = ['uniform', 'Matrix', vecSize, 'fv'].join('');
                manager.fill = function (data) {
                    gl[uniformMethodName](position, false, new ArrayType(data));
                };
                break;
            case '2D':
                {
                    var textureUnitIndex = textureCount;
                    var textureUnitName = 'TEXTURE' + textureUnitIndex;
                    if (textureCount === maxTextureImageUnits) {
                        throw 'texture size exceed max texture image units';
                    } else {
                        textureCount++;
                    }

                    manager.createTexture = function (image) {
                        var flipY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

                        var texture = gl.createTexture();

                        gl.activeTexture(gl[textureUnitName]);
                        gl.bindTexture(gl.TEXTURE_2D, texture);

                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

                        if (flipY) {
                            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                        }

                        if (image instanceof Uint8Array) {
                            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
                        } else {
                            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                        }

                        if (flipY) {
                            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                        }

                        gl.bindTexture(gl.TEXTURE_2D, null);
                        return texture;
                    };
                    manager.fill = function (texture) {
                        gl.activeTexture(gl[textureUnitName]);
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        gl.uniform1i(position, textureUnitIndex);
                    };

                    manager.update = function (texture, image) {
                        gl.activeTexture(gl[textureUnitName]);
                        gl.bindTexture(gl.TEXTURE_2D, texture);
                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                    };
                    break;
                }
            default:
                throw 'baseVecType invalid';
        }

        return _extends({ type: type }, manager);
    }

    var maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);

    var _createShaderProgram = createShaderProgram(vShader, fShader, gl),
        program = _createShaderProgram.program,
        attributeList = _createShaderProgram.attributes,
        uniformList = _createShaderProgram.uniforms;

    var attributes = {};
    var uniforms = {};
    attributeList.forEach(function (attribute) {
        attributes[attribute.name] = attributeManager(attribute, program, gl);
    });
    uniformList.forEach(function (uniform) {
        var name = uniform.name;
        if (name.endsWith('[0]')) {
            name = name.replace('[0]', '');
        }
        uniforms[name] = uniformManager(uniform, program, gl);
    });

    gl.useProgram(program);

    return {
        program: program,
        uniforms: uniforms,
        attributes: attributes,

        drawArrays: function drawArrays(count) {
            gl.drawArrays(gl.TRIANGLES, 0, count);
        },

        drawElements: function drawElements(count) {
            gl.drawElements(gl.TRIANGLES, count, gl.UNSIGNED_SHORT, 0);
        },

        createElementsBuffer: function createElementsBuffer(value) {
            var buffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(value), gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
            return buffer;
        },

        fillElements: function fillElements(buffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
            return buffer;
        },

        createFramebuffer: function createFramebuffer(width, height) {
            var useColorBuffer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;


            var framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            var colorTarget = void 0,
                depthTarget = void 0;

            if (useColorBuffer) {
                var _renderbuffer = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, _renderbuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, width, height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, _renderbuffer);
                colorTarget = _renderbuffer;
            } else {
                var tex = gl.createTexture();
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
                colorTarget = tex;
            }

            var renderbuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
            depthTarget = renderbuffer;

            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE) {
                throw new Erroe("this combination of attachments does not work");
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            return {
                framebuffer: framebuffer,
                colorTarget: colorTarget, depthTarget: depthTarget
            };
        }
    };
}

exports.compile = compile;